\renewcommand*\chapterpagestyle{scrheadings}
\chapter{Technologies}

This chapter provides an overview of the key
technologies used in the project.
Each technology was chosen for its unique benefits in
addressing specific project requirements, from rapid
prototyping to high-performance, resource-constrained deployments.

\section{Programming Languages}
This section examines the programming languages employed
in the project,
outlining their strengths and the context in which they
were used.

\subsection{Kotlin}
Kotlin\footnote{Kotlin \cite{kotlin}} was initially selected
for its seamless interoperability with Java.
This allowed rapid prototyping by leveraging the extensive
Java ecosystem, including existing libraries, frameworks,
and development tools.
However, after further evaluation and a small Kotlin prototype,
it was decided that Kotlin would not be the best choice for this project.
The evaluation indicated that as the project scaled with many microservices,
Kotlin's performance would likely be insufficient to meet the 1-second response time goal.
This led to the consideration and eventual adoption of Rust.

\subsection{Rust}
Rust\footnote{Rust \cite{rust}} was adopted for its ability to
deliver C-like performance
while ensuring memory safety through modern tooling and a robust
ownership model.
Its compile-time guarantees help avoid common pitfalls such as
null pointer dereferences and data races.
These features make Rust especially well-suited for managing
resource-intensive workloads
and scaling microservices on low-end hardware, such as a Raspberry Pi,
without sacrificing efficiency or productivity.

\section{Frameworks}
This section details the frameworks integrated into the project,
each chosen to support specific architectural patterns and
enhance development efficiency.

\subsection{Spring}
The Spring Framework\footnote{Spring \cite{spring}} was chosen for its
strong support for building microservices
and its deep integration with the Java ecosystem.
Built around the Model-View-Controller (MVC) architecture,
Spring offers a well-organized structure
for developing web applications, which aligns seamlessly with
the projectâ€™s design objectives.

\subsection{Tokio}
Tokio\footnote{Tokio \cite{tokio}} is an asynchronous runtime for Rust
that simplifies the development of non-blocking, concurrent applications.
Its ability to manage asynchronous I/O operations efficiently makes it
ideal for preventing busy waiting,
ensuring that the project can handle high concurrency and maintain
optimal performance even under heavy load.

\section{Utilities}
These are utilities, such as libraries or other tools that improve quality of life but aren't strictly neccessary.

\subsection{Serde}
Serde\footnote{Serde \cite{serde}} is a framework for serializing and deserializing Rust data structures efficiently and generically.
It was used to convert json responses to Rust structs for ease of use and safety.

\subsection{Reqwest}
Reqwest\footnote{Reqwest \cite{reqwest}} is a high-level HTTP client library for Rust.
It provides an ergonomic interface for making HTTP requests while leveraging the async/await syntax supported by Tokio.
The library was chosen for its robust error handling, built-in JSON support through Serde integration, and its simple yet powerful API design.

\subsection{Cpal}
Cpal\footnote{Cpal \cite{cpal}} is a low-level cross-platform audio I/O library for Rust.
It provides a pure-Rust interface for audio playback and recording across different operating systems.
The library was chosen for its cross-platform compatibility, low overhead, and native integration with Rust's async ecosystem,
making it ideal for handling real-time audio processing requirements in the project.

\subsection{Whisper-rs}
Whisper-rs\footnote{Whisper-rs \cite{whisper-rs}} provides Rust bindings to OpenAI's Whisper model through its C++ implementation.
The library enables local speech-to-text transcription without requiring external API calls or cloud services.
Integration with the project's Rust codebase is handled through a safe interface to the native C++ code,
while maintaining memory safety and proper resource management.
